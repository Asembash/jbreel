# jbreel_crypto_bot/main.py

import time
import hmac
import hashlib
import requests
import json
import telegram
import os
import pickle

API_KEY = os.getenv("COINEX_API_KEY")
API_SECRET = os.getenv("COINEX_API_SECRET")
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

bot = telegram.Bot(token=TG_TOKEN)

BASE_URL = 'https://api.coinex.com'
LEARNING_FILE = "market_learning.pkl"
TRADE_LOG_FILE = "trade_log.json"

# === Create API Signature ===
def create_signature(method, path, timestamp):
    message = f"{method}{path}{timestamp}"
    return hmac.new(API_SECRET.encode(), message.encode(), hashlib.sha256).hexdigest()

# === Authenticated Request ===
def make_request(method, path, payload=None):
    timestamp = int(time.time() * 1000)
    signature = create_signature(method, path, timestamp)
    headers = {
        'X-COINEX-KEY': API_KEY,
        'X-COINEX-SIGNATURE': signature,
        'X-COINEX-TIMESTAMP': str(timestamp),
        'Content-Type': 'application/json'
    }
    url = BASE_URL + path
    if method == 'GET':
        return requests.get(url, headers=headers).json()
    elif method == 'POST':
        return requests.post(url, headers=headers, data=json.dumps(payload)).json()

# === Get Balance ===
def get_balance():
    res = make_request('GET', '/v2/account/info')
    return float(res['data']['USDT']['available'])

# === Load Learning Memory ===
def load_memory():
    try:
        with open(LEARNING_FILE, 'rb') as f:
            return pickle.load(f)
    except:
        return {}

# === Save Learning Memory ===
def save_memory(mem):
    with open(LEARNING_FILE, 'wb') as f:
        pickle.dump(mem, f)

# === Save Trade Log ===
def save_trade_log(entry):
    try:
        with open(TRADE_LOG_FILE, 'r') as f:
            logs = json.load(f)
    except:
        logs = []
    logs.append(entry)
    with open(TRADE_LOG_FILE, 'w') as f:
        json.dump(logs, f, indent=2)

# === Analyze Market Dynamically with Learning ===
def analyze_market():
    symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XAUUSDT']
    mem = load_memory()
    best = {"symbol": None, "confidence": 0}
    for symbol in symbols:
        try:
            res = requests.get(f"https://api.coinex.com/v2/market/kline?market={symbol}&interval=900&limit=10").json()
            klines = res['data']['klines'] if 'klines' in res['data'] else res['data']
            close_prices = [float(k[4]) for k in klines]
            avg = sum(close_prices) / len(close_prices)
            last = close_prices[-1]
            change = (last - avg) / avg
            confidence = round(0.5 + change * 50, 2)

            prev_conf = mem.get(symbol, 0.5)
            new_conf = (prev_conf + confidence) / 2
            mem[symbol] = new_conf

            if new_conf > best['confidence']:
                best = {"symbol": symbol, "side": "buy" if change > 0 else "sell", "confidence": new_conf, "entry": last}
        except Exception as e:
            bot.send_message(chat_id=TG_CHAT_ID, text=f"⚠️ خطأ أثناء تحليل {symbol}: {e}")
            continue

    save_memory(mem)
    return best

# === Execute Trade ===
def execute_trade(signal):
    if signal['side'] == 'sell':
        symbol_asset = signal['symbol'].replace('USDT', '')
        balance_info = make_request('GET', '/v2/account/info')
        asset_balance = float(balance_info['data'].get(symbol_asset, {}).get('available', 0))
        if asset_balance <= 0:
            bot.send_message(chat_id=TG_CHAT_ID, text=f"🚫 لا يوجد رصيد كافٍ لبيع {symbol_asset}.")
            return
        amount = round(asset_balance * 0.1, 6)
    else:
        usdt_balance = get_balance()
        amount = round(usdt_balance * 0.1, 2)
        if amount < 1:
            bot.send_message(chat_id=TG_CHAT_ID, text="🚫 الرصيد غير كافٍ للشراء.")
            return

    trade_type = 1 if signal['side'] == 'buy' else 2

    # Get real-time best price from order book
    orderbook = requests.get(f"https://api.coinex.com/v2/market/depth?market={signal['symbol']}&limit=1").json()
    if signal['side'] == 'buy':
        best_price = float(orderbook['data']['asks'][0][0]) * 1.001
    else:
        best_price = float(orderbook['data']['bids'][0][0]) * 0.999

    payload = {
        "market": signal['symbol'],
        "amount": str(amount),
        "type": trade_type,
        "price": str(round(best_price, 4)),
        "client_id": f"jbreel-{int(time.time())}"
    }

    direction = "شراء 🟢" if signal['side'] == 'buy' else "بيع 🔴"
    msg = (
        f"[Jbreel Crypto] تنفيذ صفقة {direction}\n"
        f"العملة: {signal['symbol']}\n"
        f"السعر: {round(best_price, 4)} USDT\n"
        f"القيمة: {amount} USDT\n"
        f"الثقة: {signal['confidence']}"
    )
    bot.send_message(chat_id=TG_CHAT_ID, text=msg)

    save_trade_log({"symbol": signal['symbol'], "side": signal['side'], "price": round(best_price, 4), "amount": amount, "confidence": signal['confidence'], "timestamp": int(time.time())})

    return make_request('POST', '/v2/order/limit', payload)

# === Main Loop ===
if __name__ == '__main__':
    while True:
        try:
            signal = analyze_market()
            if signal['confidence'] >= 0.9:
                execute_trade(signal)
            else:
                bot.send_message(chat_id=TG_CHAT_ID, text=f"[Jbreel Crypto] لا توجد صفقة مناسبة حالياً، أفضل فرصة هي {signal['symbol']} بثقة {signal['confidence']}")
            time.sleep(60)
        except Exception as e:
            bot.send_message(chat_id=TG_CHAT_ID, text=f"⚠️ خطأ: {str(e)}")
            time.sleep(60)

# === End of Jbreel Bot ===
